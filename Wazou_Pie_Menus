# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

bl_info = {
    "name": "Wazou_Pie_Menus",
    "author": "Cédric Lepiller & DavideDozza & Lapineige & Leafar & 0rAngE",
    "version": (0, 1, 6),
    "blender": (2, 71, 4),
    "description": "Custom Pie Menus",
    "category": "3D View",}
    
import bpy
from bpy.types import Menu   
from bpy.props import IntProperty, FloatProperty, BoolProperty
import bmesh
from mathutils import *
import math

class WazouPieMenuPrefs(bpy.types.AddonPreferences):
    """Creates the tools in a Panel, in the scene context of the properties editor"""
    bl_idname = __name__

    bpy.types.Scene.Enable_Tab_01 = bpy.props.BoolProperty(default=False)
    bpy.types.Scene.Enable_Tab_02 = bpy.props.BoolProperty(default=False)
    bpy.types.Scene.Enable_Tab_03 = bpy.props.BoolProperty(default=False)

    def draw(self, context):
        layout = self.layout

        layout.prop(context.scene, "Enable_Tab_01", text="Info", icon="QUESTION")
        if context.scene.Enable_Tab_01:
            row = layout.row()
            layout.label(text="This Addon Need to activate 'Loop Tools' and 'Bsurfaces' in the Addon Tab to work properly.")
            layout.label(text="You need to install Iceking's Tool And Auto Mirror")
            
            layout.operator("wm.url_open", text="IceKing's tools").url = "http://www.blenderartists.org/forum/showthread.php?343641-Iceking-s-Tools"
            layout.operator("wm.url_open", text="Auto Mirror").url = "http://le-terrier-de-lapineige.over-blog.com/2014/07/automirror-mon-add-on-pour-symetriser-vos-objets-rapidement.html"
        
        layout.prop(context.scene, "Enable_Tab_02", text="Shortcuts", icon="QUESTION")
        if context.scene.Enable_Tab_02:
            row = layout.row()    
            layout.label(text="– Object/Edit mode > Tab")
            layout.label(text="– Views > Space")
            layout.label(text="– Sculpt > W & Alt + W")
            layout.label(text="– Cursor/Origin > Shift + S")
            layout.label(text="– Manipulators > Ctrl + Space")
            layout.label(text="– Snapping > Shift + Tab")
            layout.label(text="– Orientation > Alt + Space")
            layout.label(text="– Retopo > Shift + RMB")
            layout.label(text="– Shading > Z")
            layout.label(text="– Views Ortho > Q")
            layout.label(text="– CursorOrigin > Alt + Q")
            layout.label(text="– Proportionnal Editing > ;")

        layout.prop(context.scene, "Enable_Tab_03", text="URL's", icon="URL")   
        if context.scene.Enable_Tab_03:
            row = layout.row()
            row.operator("wm.url_open", text="Pitiwazou.com").url = "http://www.pitiwazou.com/"
            row.operator("wm.url_open", text="Wazou's Ghitub").url = "https://github.com/pitiwazou/Scripts-Blender"
            row.operator("wm.url_open", text="BlenderLounge Forum ").url = "http://blenderlounge.fr/forum/"
            
        return {'FINISHED'}
#####################################
#      Proportional Edit Object     #               
#####################################
class ProportionalEditObj(bpy.types.Operator):
    bl_idname = "proportional_obj.active"
    bl_label = "Proportional Edit Object"
    
    def execute(self, context):
        layout = self.layout 
        
        if bpy.context.scene.tool_settings.use_proportional_edit_objects == (True):
            bpy.context.scene.tool_settings.use_proportional_edit_objects = False
            
        elif bpy.context.scene.tool_settings.use_proportional_edit_objects == (False) :
             bpy.context.scene.tool_settings.use_proportional_edit_objects = True

        return {'FINISHED'}


class ProportionalSmoothObj(bpy.types.Operator):
    bl_idname = "proportional_obj.smooth"
    bl_label = "Proportional Smooth Object"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.use_proportional_edit_objects == (False) : 
            bpy.context.scene.tool_settings.use_proportional_edit_objects = True
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SMOOTH'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'SMOOTH': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SMOOTH' 
        return {'FINISHED'}    

class ProportionalSphereObj(bpy.types.Operator):
    bl_idname = "proportional_obj.sphere"
    bl_label = "Proportional Sphere Object"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.use_proportional_edit_objects == (False) : 
            bpy.context.scene.tool_settings.use_proportional_edit_objects = True
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SPHERE'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'SPHERE': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SPHERE' 
        return {'FINISHED'}    

class ProportionalRootObj(bpy.types.Operator):
    bl_idname = "proportional_obj.root"
    bl_label = "Proportional Root Object"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.use_proportional_edit_objects == (False) : 
            bpy.context.scene.tool_settings.use_proportional_edit_objects = True
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'ROOT'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'ROOT': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'ROOT' 
        return {'FINISHED'}
    
class ProportionalSharpObj(bpy.types.Operator):
    bl_idname = "proportional_obj.sharp"
    bl_label = "Proportional Sharp Object"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.use_proportional_edit_objects == (False) : 
            bpy.context.scene.tool_settings.use_proportional_edit_objects = True
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SHARP'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'SHARP': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SHARP' 
        return {'FINISHED'}
    
class ProportionalLinearObj(bpy.types.Operator):
    bl_idname = "proportional_obj.linear"
    bl_label = "Proportional Linear Object"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.use_proportional_edit_objects == (False) : 
            bpy.context.scene.tool_settings.use_proportional_edit_objects = True
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'LINEAR'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'LINEAR': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'LINEAR' 
        return {'FINISHED'}  

class ProportionalConstantObj(bpy.types.Operator):
    bl_idname = "proportional_obj.constant"
    bl_label = "Proportional Constant Object"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.use_proportional_edit_objects == (False) : 
            bpy.context.scene.tool_settings.use_proportional_edit_objects = True
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'CONSTANT'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'CONSTANT': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'CONSTANT'
        return {'FINISHED'}  

class ProportionalRandomObj(bpy.types.Operator):
    bl_idname = "proportional_obj.random"
    bl_label = "Proportional Random Object"

    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.use_proportional_edit_objects == (False) : 
            bpy.context.scene.tool_settings.use_proportional_edit_objects = True
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'RANDOM'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'RANDOM': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'RANDOM'
        return {'FINISHED'}

#######################################
#      Proportional Edit EditMode     #               
#######################################
class ProportionalEditEdt(bpy.types.Operator):
    bl_idname = "proportional_edt.active"
    bl_label = "Proportional Edit EditMode"
    
    def execute(self, context):
        layout = self.layout 
        
        if bpy.context.scene.tool_settings.proportional_edit != ('DISABLED'):
            bpy.context.scene.tool_settings.proportional_edit = 'DISABLED'
        elif bpy.context.scene.tool_settings.proportional_edit != ('ENABLED'):
            bpy.context.scene.tool_settings.proportional_edit = 'ENABLED'
        return {'FINISHED'}

class ProportionalConnectedEdt(bpy.types.Operator):
    bl_idname = "proportional_edt.connected"
    bl_label = "Proportional Connected EditMode"
    
    def execute(self, context):
        layout = self.layout 
        
        if bpy.context.scene.tool_settings.proportional_edit != ('CONNECTED'):
            bpy.context.scene.tool_settings.proportional_edit = 'CONNECTED'
        return {'FINISHED'}

class ProportionalProjectedEdt(bpy.types.Operator):
    bl_idname = "proportional_edt.projected"
    bl_label = "Proportional Connected EditMode"
    
    def execute(self, context):
        layout = self.layout 
        
        if bpy.context.scene.tool_settings.proportional_edit != ('PROJECTED'):
            bpy.context.scene.tool_settings.proportional_edit = 'PROJECTED'
        return {'FINISHED'}

class ProportionalSmoothEdt(bpy.types.Operator):
    bl_idname = "proportional_edt.smooth"
    bl_label = "Proportional Smooth EditMode"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.proportional_edit == ('DISABLED') : 
            bpy.context.scene.tool_settings.proportional_edit = 'ENABLED'
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SMOOTH'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'SMOOTH': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SMOOTH' 
        return {'FINISHED'}    

class ProportionalSphereEdt(bpy.types.Operator):
    bl_idname = "proportional_edt.sphere"
    bl_label = "Proportional Sphere EditMode"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.proportional_edit == ('DISABLED') : 
            bpy.context.scene.tool_settings.proportional_edit = 'ENABLED'
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SPHERE'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'SPHERE': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SPHERE' 
        return {'FINISHED'}    

class ProportionalRootEdt(bpy.types.Operator):
    bl_idname = "proportional_edt.root"
    bl_label = "Proportional Root EditMode"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.proportional_edit == ('DISABLED') : 
            bpy.context.scene.tool_settings.proportional_edit = 'ENABLED'
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'ROOT'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'ROOT': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'ROOT' 
        return {'FINISHED'}
    
class ProportionalSharpEdt(bpy.types.Operator):
    bl_idname = "proportional_edt.sharp"
    bl_label = "Proportional Sharp EditMode"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.proportional_edit == ('DISABLED') : 
            bpy.context.scene.tool_settings.proportional_edit = 'ENABLED'
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SHARP'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'SHARP': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'SHARP' 
        return {'FINISHED'}
    
class ProportionalLinearEdt(bpy.types.Operator):
    bl_idname = "proportional_edt.linear"
    bl_label = "Proportional Linear EditMode"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.proportional_edit == ('DISABLED') : 
            bpy.context.scene.tool_settings.proportional_edit = 'ENABLED'
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'LINEAR'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'LINEAR': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'LINEAR' 
        return {'FINISHED'}  

class ProportionalConstantEdt(bpy.types.Operator):
    bl_idname = "proportional_edt.constant"
    bl_label = "Proportional Constant EditMode"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.proportional_edit == ('DISABLED') : 
            bpy.context.scene.tool_settings.proportional_edit = 'ENABLED'
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'CONSTANT'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'CONSTANT': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'CONSTANT'
        return {'FINISHED'}  

class ProportionalRandomEdt(bpy.types.Operator):
    bl_idname = "proportional_edt.random"
    bl_label = "Proportional Random EditMode"

    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.proportional_edit == ('DISABLED') : 
            bpy.context.scene.tool_settings.proportional_edit = 'ENABLED'
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'RANDOM'
            
        if bpy.context.scene.tool_settings.proportional_edit_falloff != 'RANDOM': 
            bpy.context.scene.tool_settings.proportional_edit_falloff = 'RANDOM'
        return {'FINISHED'}

######################
#      Snapping      #               
######################
class SnapActive(bpy.types.Operator):
    bl_idname = "snap.active"
    bl_label = "Snap Active"
    
    def execute(self, context):
        layout = self.layout 
        
        if bpy.context.scene.tool_settings.use_snap == (True):
            bpy.context.scene.tool_settings.use_snap = False
            
        elif bpy.context.scene.tool_settings.use_snap == (False) :
             bpy.context.scene.tool_settings.use_snap = True

        return {'FINISHED'}


class SnapVolume(bpy.types.Operator):
    bl_idname = "snap.volume"
    bl_label = "Snap Volume"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.use_snap == (False) : 
            bpy.context.scene.tool_settings.use_snap = True
            bpy.context.scene.tool_settings.snap_element = 'VOLUME'
            
        if bpy.context.scene.tool_settings.snap_element != 'VOLUME': 
            bpy.context.scene.tool_settings.snap_element = 'VOLUME' 
        return {'FINISHED'}    

class SnapFace(bpy.types.Operator):
    bl_idname = "snap.face"
    bl_label = "Snap Face"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.use_snap == (False) : 
            bpy.context.scene.tool_settings.use_snap = True 
            bpy.context.scene.tool_settings.snap_element = 'FACE'
            
        if bpy.context.scene.tool_settings.snap_element != 'FACE': 
            bpy.context.scene.tool_settings.snap_element = 'FACE' 
        return {'FINISHED'}    

class SnapEdge(bpy.types.Operator):
    bl_idname = "snap.edge"
    bl_label = "Snap Edge"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.scene.tool_settings.use_snap == (False) : 
            bpy.context.scene.tool_settings.use_snap = True 
            bpy.context.scene.tool_settings.snap_element = 'EDGE'
        
        if bpy.context.scene.tool_settings.snap_element != 'EDGE': 
            bpy.context.scene.tool_settings.snap_element = 'EDGE' 
        return {'FINISHED'}
    
class SnapVertex(bpy.types.Operator):
    bl_idname = "snap.vertex"
    bl_label = "Snap Vertex"
    
    def execute(self, context):
        layout = self.layout 
        if bpy.context.scene.tool_settings.use_snap == (False) : 
            bpy.context.scene.tool_settings.use_snap = True
            bpy.context.scene.tool_settings.snap_element = 'VERTEX'
        
        if bpy.context.scene.tool_settings.snap_element != 'VERTEX': 
            bpy.context.scene.tool_settings.snap_element = 'VERTEX' 
        return {'FINISHED'}
    
class SnapIncrement(bpy.types.Operator):
    bl_idname = "snap.increment"
    bl_label = "Snap Increment"
    
    def execute(self, context):
        layout = self.layout 
        if bpy.context.scene.tool_settings.use_snap == (False) : 
            bpy.context.scene.tool_settings.use_snap = True
            bpy.context.scene.tool_settings.snap_element = 'INCREMENT'
            
        if bpy.context.scene.tool_settings.snap_element != 'INCREMENT': 
            bpy.context.scene.tool_settings.snap_element = 'INCREMENT'    
        return {'FINISHED'}  

class SnapAlignRotation(bpy.types.Operator):
    bl_idname = "snap.alignrotation"
    bl_label = "Snap Align rotation"
    
    def execute(self, context):
        layout = self.layout 
        if bpy.context.scene.tool_settings.use_snap_align_rotation == (True) :
            bpy.context.scene.tool_settings.use_snap_align_rotation = False
            
        elif bpy.context.scene.tool_settings.use_snap_align_rotation == (False) :
             bpy.context.scene.tool_settings.use_snap_align_rotation = True
        
        return {'FINISHED'} 

class SnapTargetVariable(bpy.types.Operator):
    bl_idname = "object.snaptargetvariable"
    bl_label = "Snap Target Variable"
    variable = bpy.props.StringProperty()

    @classmethod
    def poll(cls, context):
        return True

    def execute(self, context):
        bpy.context.scene.tool_settings.snap_target=self.variable
        return {'FINISHED'} 
######################
#    Orientation     #               
######################

class OrientationVariable(bpy.types.Operator):
    bl_idname = "object.orientationvariable"
    bl_label = "Orientation Variable"
    variable = bpy.props.StringProperty()

    @classmethod
    def poll(cls, context):
        return True

    def execute(self, context):
        bpy.context.space_data.transform_orientation=self.variable
        return {'FINISHED'} 

######################
#      Shading       #               
######################

class ShadingVariable(bpy.types.Operator):
    bl_idname = "object.shadingvariable"
    bl_label = "Shading Variable"
    variable = bpy.props.StringProperty()

    @classmethod
    def poll(cls, context):
        return True

    def execute(self, context):
        bpy.context.space_data.viewport_shade=self.variable
        return {'FINISHED'} 
    
class ShadingSmooth(bpy.types.Operator):
    bl_idname = "shading.smooth"
    bl_label = "Shading Smooth"
    
    def execute(self, context):
        if bpy.context.object.mode == "OBJECT":
            bpy.ops.object.shade_smooth()
            
        elif bpy.context.object.mode == "EDIT":
            bpy.ops.object.mode_set(mode = 'OBJECT')
            bpy.ops.object.shade_smooth()
            bpy.ops.object.mode_set(mode = 'EDIT')
        return {'FINISHED'} 
    
class ShadingFlat(bpy.types.Operator):
    bl_idname = "shading.flat"
    bl_label = "Shading Flat"
    
    def execute(self, context):
        if bpy.context.object.mode == "OBJECT":
            bpy.ops.object.shade_flat()
            
        elif bpy.context.object.mode == "EDIT":
            bpy.ops.object.mode_set(mode = 'OBJECT')
            bpy.ops.object.shade_flat()
            bpy.ops.object.mode_set(mode = 'EDIT')
        return {'FINISHED'} 
   
######################
#    Pivot Point     #               
######################

class PivotPointVariable(bpy.types.Operator):
    bl_idname = "pivotpoint.variable"
    bl_label = "PivotPointVariable"
    variable = bpy.props.StringProperty()

    @classmethod
    def poll(cls, context):
        return True

    def execute(self, context):
        bpy.context.space_data.pivot_point = self.variable
        return {'FINISHED'} 
    

class UsePivotAlign(bpy.types.Operator):
    bl_idname = "use.pivotalign"
    bl_label = "Use Pivot Align"
    
    def execute(self, context):
        
        if bpy.context.space_data.use_pivot_point_align == (False) :
            bpy.context.space_data.use_pivot_point_align = True
        elif bpy.context.space_data.use_pivot_point_align == (True) :
             bpy.context.space_data.use_pivot_point_align = False
        return {'FINISHED'}
    
######################
#    Manipulators    #               
######################
class ManipTranslate(bpy.types.Operator):
    bl_idname = "manip.translate"
    bl_label = "Manip Translate"
    
    def execute(self, context):
        layout = self.layout 
        if bpy.context.space_data.show_manipulator == (False) :
            bpy.context.space_data.show_manipulator = True
            bpy.context.space_data.transform_manipulators = {'TRANSLATE'}
        if bpy.context.space_data.transform_manipulators != {'TRANSLATE'}:
            bpy.context.space_data.transform_manipulators = {'TRANSLATE'}
        return {'FINISHED'}

class ManipRotate(bpy.types.Operator):
    bl_idname = "manip.rotate"
    bl_label = "Manip Rotate"
    
    def execute(self, context):
        layout = self.layout 
        if bpy.context.space_data.show_manipulator == (False) :
            bpy.context.space_data.show_manipulator = True
            bpy.context.space_data.transform_manipulators = {'ROTATE'}
        if bpy.context.space_data.transform_manipulators != {'ROTATE'}:
            bpy.context.space_data.transform_manipulators = {'ROTATE'}
        return {'FINISHED'}
    
class ManipScale(bpy.types.Operator):
    bl_idname = "manip.scale"
    bl_label = "Manip Scale"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.space_data.show_manipulator == (False) :
            bpy.context.space_data.show_manipulator = True
            bpy.context.space_data.transform_manipulators = {'SCALE'}
        if bpy.context.space_data.transform_manipulators != {'SCALE'}:
            bpy.context.space_data.transform_manipulators = {'SCALE'}
        return {'FINISHED'}

class TranslateRotate(bpy.types.Operator):
    bl_idname = "translate.rotate"
    bl_label = "Translate Rotate"
    
    def execute(self, context):
        layout = self.layout 
        if bpy.context.space_data.show_manipulator == (False) :
            bpy.context.space_data.show_manipulator = True
            bpy.context.space_data.transform_manipulators = {'TRANSLATE', 'ROTATE'}
        if bpy.context.space_data.transform_manipulators != {'TRANSLATE', 'ROTATE'}:
            bpy.context.space_data.transform_manipulators = {'TRANSLATE', 'ROTATE'}
        return {'FINISHED'}
    
class TranslateScale(bpy.types.Operator):
    bl_idname = "translate.scale"
    bl_label = "Translate Scale"
    
    def execute(self, context):
        layout = self.layout 
        if bpy.context.space_data.show_manipulator == (False) :
            bpy.context.space_data.show_manipulator = True
            bpy.context.space_data.transform_manipulators = {'TRANSLATE', 'SCALE'}
        if bpy.context.space_data.transform_manipulators != {'TRANSLATE', 'SCALE'}:
            bpy.context.space_data.transform_manipulators = {'TRANSLATE', 'SCALE'}
        return {'FINISHED'}

class RotateScale(bpy.types.Operator):
    bl_idname = "rotate.scale"
    bl_label = "Rotate Scale"
    
    def execute(self, context):
        layout = self.layout 
        if bpy.context.space_data.show_manipulator == (False) :
            bpy.context.space_data.show_manipulator = True
            bpy.context.space_data.transform_manipulators = {'ROTATE', 'SCALE'}
        if bpy.context.space_data.transform_manipulators != {'ROTATE', 'SCALE'}:
            bpy.context.space_data.transform_manipulators = {'ROTATE', 'SCALE'}
        return {'FINISHED'}
    
class TranslateRotateScale(bpy.types.Operator):
    bl_idname = "translate.rotatescale"
    bl_label = "Translate Rotate Scale"
    
    def execute(self, context):
        layout = self.layout 
        if bpy.context.space_data.show_manipulator == (False) :
            bpy.context.space_data.show_manipulator = True
            bpy.context.space_data.transform_manipulators = {'TRANSLATE', 'ROTATE', 'SCALE'}
        if bpy.context.space_data.transform_manipulators != {'TRANSLATE', 'ROTATE', 'SCALE'}:
            bpy.context.space_data.transform_manipulators = {'TRANSLATE', 'ROTATE', 'SCALE'}
        return {'FINISHED'}
        
class WManupulators(bpy.types.Operator):
    bl_idname = "w.manupulators"
    bl_label = "W Manupulators"
    
    def execute(self, context):
        layout = self.layout 
        
        if bpy.context.space_data.show_manipulator == (True):
            bpy.context.space_data.show_manipulator = False
            
        elif bpy.context.space_data.show_manipulator == (False):
             bpy.context.space_data.show_manipulator = True

        return {'FINISHED'}

######################
#       Modes        #               
######################

# Define Class Texture Paint
class ClassTexturePaint(bpy.types.Operator):
    bl_idname = "class.pietexturepaint"
    bl_label = "Class Texture Paint"
    
    def execute(self, context):
        layout = self.layout
        
        if bpy.context.object.mode == "EDIT":
            bpy.ops.object.mode_set(mode="OBJECT")
            bpy.ops.paint.texture_paint_toggle()
        else:
            bpy.ops.paint.texture_paint_toggle()
        return {'FINISHED'}
        
# Define Class Weight Paint
class ClassWeightPaint(bpy.types.Operator):
    bl_idname = "class.pieweightpaint"
    bl_label = "Class Weight Paint"
    
    def execute(self, context):
        layout = self.layout
        
        if bpy.context.object.mode == "EDIT":
            bpy.ops.object.mode_set(mode="OBJECT")
            bpy.ops.paint.weight_paint_toggle()
        else:
            bpy.ops.paint.weight_paint_toggle()
        return {'FINISHED'}
    
# Define Class Vertex Paint
class ClassVertexPaint(bpy.types.Operator):
    bl_idname = "class.pievertexpaint"
    bl_label = "Class Vertex Paint"
    
    def execute(self, context):
        layout = self.layout
        
        if bpy.context.object.mode == "EDIT":
            bpy.ops.object.mode_set(mode="OBJECT")
            bpy.ops.paint.vertex_paint_toggle()
        else:
            bpy.ops.paint.vertex_paint_toggle()
        return {'FINISHED'}

# Define Class Object Mode
class ClassObject(bpy.types.Operator):
    bl_idname = "class.object"
    bl_label = "Class Object"
    
    def execute(self, context):
        layout = self.layout
        
        if bpy.context.object.mode == "OBJECT":
            bpy.ops.object.mode_set(mode="EDIT")
        else:
            bpy.ops.object.mode_set(mode="OBJECT") 
        return {'FINISHED'}

# Define Class Vertex
class ClassVertex(bpy.types.Operator):
    bl_idname = "class.vertex"
    bl_label = "Class Vertex"
    
    def execute(self, context):
        layout = self.layout
        
        if bpy.context.object.mode != "EDIT":
            bpy.ops.object.mode_set(mode="EDIT")
            bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='VERT')
        if bpy.ops.mesh.select_mode != "EDGE, FACE":
            bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='VERT') 
            return {'FINISHED'}

# Define Class Edge
class ClassEdge(bpy.types.Operator):
    bl_idname = "class.edge"
    bl_label = "Class Edge"
    
    def execute(self, context):
        layout = self.layout
        
        if bpy.context.object.mode != "EDIT":
            bpy.ops.object.mode_set(mode="EDIT")
            bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='EDGE')
        if bpy.ops.mesh.select_mode != "VERT, FACE":
            bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='EDGE') 
            return {'FINISHED'}

# Define Class Face
class ClassFace(bpy.types.Operator):
    bl_idname = "class.face"
    bl_label = "Class Face"
    
    def execute(self, context):
        layout = self.layout
        
        if bpy.context.object.mode != "EDIT":
            bpy.ops.object.mode_set(mode="EDIT")
            bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='FACE')
        if bpy.ops.mesh.select_mode != "VERT, EDGE":
            bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='FACE')
            return {'FINISHED'}


######################
#   Selection Mode   #               
######################

# Define Class Occlude Geometry
class ClassOccludeGeometry(bpy.types.Operator):
    bl_idname = "class.pieoccludegeo"
    bl_label = "Class Occlude Geometry"
    
    def execute(self, context):
        layout = self.layout
        
        if bpy.context.space_data.use_occlude_geometry == (True):
            bpy.context.space_data.use_occlude_geometry = False
        else:
            bpy.context.space_data.use_occlude_geometry = True
        return {'FINISHED'}        

# Components Selection Mode
class VertsEdges(bpy.types.Operator):
    bl_idname = "verts.edges"
    bl_label = "Verts Edges"
    
    def execute(self, context):
        layout = self.layout
        if bpy.context.object.mode != "EDIT":
            bpy.ops.object.mode_set(mode="EDIT")
            bpy.context.tool_settings.mesh_select_mode = (True, True, False)
        if bpy.context.object.mode == "EDIT":
            bpy.context.tool_settings.mesh_select_mode = (True, True, False)
            return {'FINISHED'}
        
 
class EdgesFaces(bpy.types.Operator):
    bl_idname = "edges.faces"
    bl_label = "EdgesFaces"
    
    def execute(self, context):
        layout = self.layout 
        if bpy.context.object.mode != "EDIT":
            bpy.ops.object.mode_set(mode="EDIT")
            bpy.context.tool_settings.mesh_select_mode = (False, True, True)
        if bpy.context.object.mode == "EDIT":
            bpy.context.tool_settings.mesh_select_mode = (False, True, True)
            return {'FINISHED'}
        
class VertsFaces(bpy.types.Operator):
    bl_idname = "verts.faces"
    bl_label = "Verts Faces"
    
    def execute(self, context):
        layout = self.layout  
        if bpy.context.object.mode != "EDIT":
            bpy.ops.object.mode_set(mode="EDIT")
            bpy.context.tool_settings.mesh_select_mode = (True, False, True)
        if bpy.context.object.mode == "EDIT":
            bpy.context.tool_settings.mesh_select_mode = (True, False, True)
            return {'FINISHED'}
    
class VertsEdgesFaces(bpy.types.Operator):
    bl_idname = "verts.edgesfaces"
    bl_label = "Verts Edges Faces"
    
    def execute(self, context):
        layout = self.layout  
        if bpy.context.object.mode != "EDIT":
            bpy.ops.object.mode_set(mode="EDIT")
            bpy.context.tool_settings.mesh_select_mode = (True, True, True)
        if bpy.context.object.mode == "EDIT":
            bpy.context.tool_settings.mesh_select_mode = (True, True, True)
            return {'FINISHED'}
        
######################
#       Views        #               
######################

# Split area horizontal
class SplitHorizontal(bpy.types.Operator):
    bl_idname = "split.horizontal"
    bl_label = "split horizontal"
    
    def execute(self, context):
        layout = self.layout

        bpy.ops.screen.area_split(direction='HORIZONTAL')
        return {'FINISHED'}

# Split area vertical
class SplitVertical(bpy.types.Operator):
    bl_idname = "split.vertical"
    bl_label = "split vertical"
    
    def execute(self, context):
        layout = self.layout

        bpy.ops.screen.area_split(direction='VERTICAL')
        return {'FINISHED'}
        
  
# Join area
class JoinArea(bpy.types.Operator):
    """Join 2 area, clic on the second area to join"""
    bl_idname = "area.joinarea"
    bl_label = "Join Area"

    min_x = IntProperty()
    min_y = IntProperty()

    def modal(self, context, event):
        if event.type == 'LEFTMOUSE':
            self.max_x = event.mouse_x
            self.max_y = event.mouse_y
            bpy.ops.screen.area_join(min_x=self.min_x, min_y=self.min_y, max_x=self.max_x, max_y=self.max_y)
            bpy.ops.screen.screen_full_area()
            bpy.ops.screen.screen_full_area()
            return {'FINISHED'}
        return {'RUNNING_MODAL'}

    def invoke(self, context, event):
        self.min_x = event.mouse_x
        self.min_y = event.mouse_y
        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}
    
#View Class menu
class ViewMenu(bpy.types.Operator):
    """Menu to change views"""
    bl_idname = "object.view_menu"
    bl_label = "View_Menu"
    variable = bpy.props.StringProperty()

    @classmethod
    def poll(cls, context):
        return True

    def execute(self, context):
        bpy.context.area.type=self.variable
        return {'FINISHED'} 
##############
#   Sculpt   #               
##############

# Sculpt Polish
class SculptPolish(bpy.types.Operator):
    bl_idname = "sculpt.polish"
    bl_label = "Sculpt Polish"
    
    def execute(self, context):
        layout = self.layout
        bpy.context.tool_settings.sculpt.brush=bpy.data.brushes['Polish']
        return {'FINISHED'} 
     
# Sculpt Polish
class SculptSculptDraw(bpy.types.Operator):
    bl_idname = "sculpt.sculptraw"
    bl_label = "Sculpt SculptDraw"
    
    def execute(self, context):
        layout = self.layout
        bpy.context.tool_settings.sculpt.brush=bpy.data.brushes['SculptDraw']
        return {'FINISHED'}
    
######################
#   Cursor/Origin    #               
###################### 

#Pivot to selection
class PivotToSelection(bpy.types.Operator):  
    bl_idname = "object.pivot2selection"  
    bl_label = "Pivot To Selection"  
  
    def execute(self, context):  
        saved_location = bpy.context.scene.cursor_location.copy()
        bpy.ops.view3d.snap_cursor_to_selected()
        bpy.ops.object.mode_set(mode = 'OBJECT')
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')
        bpy.context.scene.cursor_location = saved_location 
        return {'FINISHED'}  

#Pivot to Bottom
class PivotBottom(bpy.types.Operator):  
    bl_idname = "object.pivotobottom"  
    bl_label = "Pivot To Bottom"  
  
    def execute(self, context):
        
        bpy.ops.object.mode_set(mode = 'OBJECT')
        bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
        bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY')
        o=bpy.context.active_object
        init=0
        for x in o.data.vertices:
             if init==0:
                 a=x.co.z
                 init=1
             elif x.co.z<a:
                 a=x.co.z
                 
        for x in o.data.vertices:
             x.co.z-=a

        o.location.z+=a 
        bpy.ops.object.mode_set(mode = 'EDIT')
        return {'FINISHED'}   
     
###############
#   Retopo    #               
###############

#Align to X
class AlignToX(bpy.types.Operator):  
    bl_idname = "object.align2x"  
    bl_label = "Align To X"  
  
    def execute(self, context):
        bpy.ops.object.mode_set(mode = 'OBJECT')
        bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)

        for vert in bpy.context.object.data.vertices:
            if vert.select: 
                vert.co[0] = 0
        bpy.ops.object.editmode_toggle() 
        return {'FINISHED'} 

#LapRelax
class LapRelax(bpy.types.Operator):
    bl_idname = "mesh.laprelax"
    bl_label = "LapRelax"
    bl_description = "Smoothing mesh keeping volume"
    bl_options = {'REGISTER', 'UNDO'}
    
    Repeat = bpy.props.IntProperty(
        name = "Repeat", 
        description = "Repeat how many times",
        default = 1,
        min = 1,
        max = 100)


    @classmethod
    def poll(cls, context):
        obj = context.active_object
        return (obj and obj.type == 'MESH' and context.mode == 'EDIT_MESH')

    def invoke(self, context, event):
        
        # smooth #Repeat times
        for i in range(self.Repeat):
            self.do_laprelax()
        
        return {'FINISHED'}


    def do_laprelax(self):
    
        context = bpy.context
        region = context.region  
        area = context.area
        selobj = bpy.context.active_object
        mesh = selobj.data
        bm = bmesh.from_edit_mesh(mesh)
        bmprev = bm.copy()
    
        for v in bmprev.verts:
            if v.select:
                tot = Vector((0, 0, 0))
                cnt = 0
                for e in v.link_edges:
                    for f in e.link_faces:
                        if not(f.select):
                            cnt = 1
                    if len(e.link_faces) == 1:
                        cnt = 1
                        break
                if cnt:
                    # dont affect border edges: they cause shrinkage
                    continue
                    
                # find Laplacian mean
                for e in v.link_edges:
                    tot += e.other_vert(v).co
                tot /= len(v.link_edges)
                
                # cancel movement in direction of vertex normal
                delta = (tot - v.co)
                if delta.length != 0:
                    ang = delta.angle(v.normal)
                    deltanor = math.cos(ang) * delta.length
                    nor = v.normal
                    nor.length = abs(deltanor)
                    bm.verts[v.index].co = tot + nor
            
            
        mesh.update()
        bm.free()
        bmprev.free()
        bpy.ops.object.editmode_toggle()
        bpy.ops.object.editmode_toggle()

#Space
class RetopoSpace(bpy.types.Operator):  
    bl_idname = "retopo.space"  
    bl_label = "Retopo Space"  
  
    def execute(self, context):
        bpy.ops.mesh.looptools_space(influence=100, input='selected', interpolation='cubic', lock_x=False, lock_y=False, lock_z=False)
        return {'FINISHED'} 

######################
#    Views Ortho     #               
######################
#Persp/Ortho
class PerspOrthoView(bpy.types.Operator):  
    bl_idname = "persp.orthoview"  
    bl_label = "Persp/Ortho"  
  
    def execute(self, context):
        bpy.ops.view3d.view_persportho()
        return {'FINISHED'} 
         
######################
#     Pie Menus      #               
######################
  
# Pie Select Mode
class PieObjectEditMode(Menu):
    bl_idname = "pie.objecteditmode"
    bl_label = "Select Mode"

    def draw(self, context):
        layout = self.layout
           
        ob = context
        if ob.object.type == 'MESH':

            pie = layout.menu_pie()
            #4 - LEFT
            pie.operator("class.vertex", text="Vertex", icon='VERTEXSEL')
            #6 - RIGHT
            pie.operator("class.face", text="Face", icon='FACESEL')
            #2 - BOTTOM
            pie.operator("class.edge", text="Edge", icon='EDGESEL')
            #8 - TOP
            pie.operator("class.object", text="Edit/Object", icon='OBJECT_DATAMODE')
            #7 - TOP - LEFT 
            pie.operator("class.pieoccludegeo", text="Occlude Geometry", icon='ORTHO')
            #9 - TOP - RIGHT
            pie.operator("sculpt.sculptmode_toggle", text="Sculpt", icon='SCULPTMODE_HLT')
            #1 - BOTTOM - LEFT
            box = pie.split().column()
            row = box.row(align=True)
            box.operator("class.pietexturepaint", text="Texture Paint", icon='TPAINT_HLT')
            box.operator("class.pievertexpaint", text="Vertex Paint", icon='VPAINT_HLT')
            box.operator("class.pieweightpaint", text="Weight Paint", icon='WPAINT_HLT')
            #3 - BOTTOM - RIGHT
            box = pie.split().column()
            row = box.row(align=True)
            box.operator("verts.faces", text="Vertex/Faces")
            box.operator("verts.edges", text="Vertex/Edges")
            box.operator("edges.faces", text="Edges/Faces")
            box.operator("verts.edgesfaces", text="Vertex/Edges/Faces")
            
            
        elif ob.object.type == 'CURVE':
            pie = layout.menu_pie()
            pie.operator("object.editmode_toggle", text="Edit/Object", icon='OBJECT_DATAMODE')
          
        elif ob.object.type == 'ARMATURE':
            pie = layout.menu_pie()
            pie.operator("object.editmode_toggle", text="Edit Mode", icon='OBJECT_DATAMODE')
            pie.operator("object.posemode_toggle", text="Pose", icon='POSE_HLT')
            pie.operator("class.object", text="Object Mode", icon='OBJECT_DATAMODE')
            
        elif ob.object.type == 'FONT':
            pie = layout.menu_pie()
            pie.operator("object.editmode_toggle", text="Edit/Object", icon='OBJECT_DATAMODE')    
        
        elif ob.object.type == 'SURFACE':
            pie = layout.menu_pie()
            pie.operator("object.editmode_toggle", text="Edit/Object", icon='OBJECT_DATAMODE')
        
        elif ob.object.type == 'ARMATURE':
            pie = layout.menu_pie()
            pie.operator("object.editmode_toggle", text="Edit/Object", icon='OBJECT_DATAMODE')   
        
        elif ob.object.type == 'META':
            pie = layout.menu_pie()
            pie.operator("object.editmode_toggle", text="Edit/Object", icon='OBJECT_DATAMODE') 
        
        elif ob.object.type == 'LATTICE':
            pie = layout.menu_pie()
            pie.operator("object.editmode_toggle", text="Edit/Object", icon='OBJECT_DATAMODE')
            
        elif ob.object.type == 'ARMATURE':
            pie = layout.menu_pie()
            pie.operator("object.editmode_toggle", text="Edit/Object", icon='OBJECT_DATAMODE')       

#Pie Views
class PieAreaViews(Menu):
    bl_idname = "pie.areaviews"
    bl_label = "Pie Views"

    def draw(self, context):
        layout = self.layout

        pie = layout.menu_pie()
        
        #4 - LEFT
        pie.operator("object.view_menu", text="Node Editor", icon= 'NODETREE').variable="NODE_EDITOR"
        #6 - RIGHT
        pie.operator("object.view_menu", text="Image Editor", icon= 'IMAGE_COL').variable="IMAGE_EDITOR"
        #2 - BOTTOM
        pie.operator_context="INVOKE_DEFAULT"
        pie.operator("area.joinarea", icon='X', text="Join Area")
        #8 - TOP
        pie.operator("object.view_menu", text="VIEW 3D", icon= 'VIEW3D').variable="VIEW_3D"
        #7 - TOP - LEFT 
        box = pie.split().column()
        row = box.row(align=True)
        box.operator("object.view_menu", text="Text Editor", icon= 'FILE_TEXT').variable="TEXT_EDITOR" 
        box.operator("object.view_menu", text="Outliner", icon= 'OOPS').variable="OUTLINER" 
        box.operator("object.view_menu", text="Properties", icon= 'BUTS').variable="PROPERTIES"
        box.operator("object.view_menu", text="User Preferences", icon= 'PREFERENCES').variable="USER_PREFERENCES" 
        #9 - TOP - RIGHT
        box = pie.split().column()
        row = box.row(align=True)
        box.operator("object.view_menu", text="Graph Editor", icon= 'IPO').variable="GRAPH_EDITOR"
        box.operator("object.view_menu", text="Dope Sheet", icon= 'ACTION').variable="DOPESHEET_EDITOR"
        box.operator("object.view_menu", text="Timeline", icon= 'TIME').variable="TIMELINE"
        box.menu("oher.viewsmenu", text="Other Views", icon= 'FULLSCREEN')
        #1 - BOTTOM - LEFT
        pie.operator("split.vertical", text="Split Vertical", icon= 'TRIA_RIGHT')
        #3 - BOTTOM - RIGHT
        pie.operator("split.horizontal", text="Split Horizontal", icon= 'TRIA_DOWN')

#Menu Other views
class OherViewsMenu(Menu):
    bl_idname = "oher.viewsmenu"
    bl_label = "Oher Views Menu"

    def draw(self, context):
        layout = self.layout
        layout.operator("object.view_menu", text="NLA Editor", icon= 'NLA').variable="NLA_EDITOR"
        layout.operator("object.view_menu", text="Sequence Editor", icon= 'SEQUENCE').variable="SEQUENCE_EDITOR"
        layout.operator("object.view_menu", text="Movie Clip Editor", icon= 'RENDER_ANIMATION').variable="CLIP_EDITOR"
        layout.operator("object.view_menu", text="Python Console", icon= 'CONSOLE').variable="CONSOLE"
        layout.operator("object.view_menu", text="File Browser", icon= 'FILESEL').variable="FILE_BROWSER"
        layout.operator("object.view_menu", text="Info", icon= 'INFO').variable="INFO"
        layout.operator("object.view_menu", text="Logic Editor", icon= 'LOGIC').variable="LOGIC_EDITOR" 
        
#Pie views numpad
class PieViewNumpad(Menu):
    bl_idname = "pie.viewnumpad"
    bl_label = "Pie Views Ortho"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("view3d.viewnumpad", text="Left", icon='TRIA_LEFT').type='LEFT'
        #6 - RIGHT
        pie.operator("view3d.viewnumpad", text="Right", icon='TRIA_RIGHT').type='RIGHT'
        #2 - BOTTOM
        pie.operator("view3d.viewnumpad", text="Bottom", icon='TRIA_DOWN').type='BOTTOM'
        #8 - TOP
        pie.operator("view3d.viewnumpad", text="Top", icon='TRIA_UP').type='TOP'
        #7 - TOP - LEFT 
        pie.operator("view3d.viewnumpad", text="Front").type='FRONT'
        #9 - TOP - RIGHT
        pie.operator("view3d.viewnumpad", text="Back").type='BACK'
        #1 - BOTTOM - LEFT
        box = pie.split().column()
        row = box.row(align=True)
        box.operator("view3d.view_all", text="View All").center = True
        box.operator("view3d.view_selected", text="View Selected")
        box.operator("persp.orthoview", text="Persp/Ortho", icon='RESTRICT_VIEW_OFF')
        box.operator("screen.screen_full_area", text="Full Screen", icon='FULLSCREEN_ENTER')
        #3 - BOTTOM - RIGHT
        box = pie.split().column()
        row = box.row(align=True)
        box.operator("view3d.localview", text="Local/Global")
        box.operator("view3d.viewnumpad", text="Camera", icon='CAMERA_DATA').type='CAMERA'
        box.operator("screen.region_quadview", text="Toggle Quad View", icon='SPLITSCREEN')
        box.operator("screen.area_dupli", text="Duplicate area")
        
#Pie Sculp Pie Menus
class PieSculptPie(Menu):
    bl_idname = "pie.sculpt"
    bl_label = "Pie Sculpt"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("paint.brush_select", text="Crease", icon='BRUSH_CREASE').sculpt_tool='CREASE'
        #6 - RIGHT
        pie.operator("paint.brush_select", text="Clay", icon='BRUSH_CLAY').sculpt_tool='CLAY'
        #2 - BOTTOM
        pie.operator("paint.brush_select", text='Flatten', icon='BRUSH_FLATTEN').sculpt_tool='FLATTEN'
        #8 - TOP
        pie.operator("paint.brush_select", text='Brush', icon='BRUSH_SCULPT_DRAW').sculpt_tool='DRAW'
        #7 - TOP - LEFT 
        pie.operator("paint.brush_select", text='Inflate/Deflate', icon='BRUSH_INFLATE').sculpt_tool='INFLATE'
        #9 - TOP - RIGHT
        pie.operator("paint.brush_select", text='Grab', icon='BRUSH_GRAB').sculpt_tool='GRAB'
        #1 - BOTTOM - LEFT
        pie.operator("paint.brush_select", text='Mask', icon='BRUSH_MASK').sculpt_tool='MASK'
        #3 - BOTTOM - RIGHT
        pie.operator("paint.brush_select", text='Fill/Deepen', icon='BRUSH_FILL').sculpt_tool='FILL'

#Pie Sculp Pie Menus 2        
class PieSculpttwo(Menu):
    bl_idname = "pie.sculpttwo"
    bl_label = "Pie Sculpt 2"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("paint.brush_select", text='Claystrips', icon='BRUSH_CREASE').sculpt_tool= 'CLAY_STRIPS'
        #6 - RIGHT
        pie.operator("paint.brush_select", text='Blob', icon='BRUSH_BLOB').sculpt_tool= 'BLOB'
        #2 - BOTTOM
        pie.operator("paint.brush_select", text='Snakehook', icon='BRUSH_SNAKE_HOOK').sculpt_tool= 'SNAKE_HOOK'
        #8 - TOP
        pie.operator("paint.brush_select", text='Smooth', icon='BRUSH_SMOOTH').sculpt_tool= 'SMOOTH'
        #7 - TOP - LEFT 
        pie.operator("paint.brush_select", text='Pinch/Magnify', icon='BRUSH_PINCH').sculpt_tool= 'PINCH'
        #9 - TOP - RIGHT
        pie.operator("sculpt.polish", text='Polish', icon='BRUSH_FLATTEN')
        #1 - BOTTOM - LEFT
        box = pie.split().column()
        row = box.row(align=True)
        box.operator("paint.brush_select", text='Twist', icon='BRUSH_ROTATE').sculpt_tool= 'ROTATE'
        box.operator("paint.brush_select", text='Scrape/Peaks', icon='BRUSH_SCRAPE').sculpt_tool= 'SCRAPE'
        box.operator("sculpt.sculptraw", text='SculptDraw', icon='BRUSH_SCULPT_DRAW')
        #3 - BOTTOM - RIGHT
        box = pie.split().column()
        row = box.row(align=True)
        box.operator("paint.brush_select", text='Layer', icon='BRUSH_LAYER').sculpt_tool= 'LAYER'
        box.operator("paint.brush_select", text='Nudge', icon='BRUSH_NUDGE').sculpt_tool= 'NUDGE'
        box.operator("paint.brush_select", text='Thumb', icon='BRUSH_THUMB').sculpt_tool= 'THUMB'

#Pie Origin/Pivot
class PieOriginPivot(Menu):
    bl_idname = "pie.originpivot"
    bl_label = "Pie Origin/Cursor"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("object.pivotobottom", text="Origin to Bottom", icon='TRIA_DOWN')
        #6 - RIGHT
        pie.operator("view3d.snap_cursor_to_selected", text="Cursor to Selected", icon='ROTACTIVE')   
        #2 - BOTTOM
        pie.operator("view3d.snap_selected_to_cursor", text="Selection to Cursor", icon='CLIPUV_HLT').use_offset = False
        #8 - TOP
        pie.operator("object.origin_set", text="Origin To 3D Cursor", icon='CURSOR').type ='ORIGIN_CURSOR'
        #7 - TOP - LEFT 
        pie.operator("object.pivot2selection", text="Origin To Selection", icon='SNAP_INCREMENT')
        #9 - TOP - RIGHT
        pie.operator("object.origin_set", text="Origin To Geometry", icon='ROTATE').type ='ORIGIN_GEOMETRY'
        #1 - BOTTOM - LEFT
        pie.operator("object.origin_set", text="Geometry To Origin", icon='BBOX').type ='GEOMETRY_ORIGIN'
        #3 - BOTTOM - RIGHT
        pie.menu("origin.pivotmenu", text="Others", icon='CURSOR')
        
#Origin/Pivot menu1
class OriginPivotMenu(Menu):
    bl_idname = "origin.pivotmenu"
    bl_label = "Origin Pivot Menu"

    def draw(self, context):
        layout = self.layout        
         
        layout.operator("object.origin_set", text="Origin to Center of Mass").type = 'ORIGIN_CENTER_OF_MASS'
        layout.operator("view3d.snap_selected_to_grid", text="Selection to Grid")
        layout.operator("view3d.snap_selected_to_cursor", text="Selection to Cursor (Offset)").use_offset = True

        layout.separator()
        
        layout.operator("view3d.snap_cursor_to_center", text="Cursor to Center")
        layout.operator("view3d.snap_cursor_to_grid", text="Cursor to Grid")
        layout.operator("view3d.snap_cursor_to_active", text="Cursor to Active")

#Pie Manipulators
class PieManipulator(Menu):
    bl_idname = "pie.manipulator"
    bl_label = "Pie Manipulator"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("manip.translate", text="Translate", icon='MAN_TRANS')
        #6 - RIGHT
        pie.operator("manip.scale", text="scale", icon='MAN_SCALE')
        #2 - BOTTOM
        pie.operator("manip.rotate", text="Rotate", icon='MAN_ROT')
        #8 - TOP
        pie.operator("w.manupulators", text="Manipulator", icon='MANIPUL')
        #7 - TOP - LEFT 
        pie.operator("translate.rotate", text="Translate/Rotate")
        #9 - TOP - RIGHT
        pie.operator("translate.scale", text="Translate/Scale")
        #1 - BOTTOM - LEFT
        pie.operator("rotate.scale", text="Rotate/Scale")
        #3 - BOTTOM - RIGHT
        pie.operator("translate.rotatescale", text="Translate/Rotate/Scale")

#Pie Snapping
class PieSnaping(Menu):
    bl_idname = "pie.snapping"
    bl_label = "Pie Snapping"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("snap.vertex", text="Vertex", icon='SNAP_VERTEX')
        #6 - RIGHT
        pie.operator("snap.face", text="Face", icon='SNAP_FACE')
        #2 - BOTTOM
        pie.operator("snap.edge", text="Edge", icon='SNAP_EDGE')
        #8 - TOP
        pie.operator("snap.active", text="Snap On/Off", icon='SNAP_ON')
        #7 - TOP - LEFT 
        pie.operator("snap.volume", text="Volume", icon='SNAP_VOLUME')
        #9 - TOP - RIGHT
        pie.operator("snap.increment", text="Increment", icon='SNAP_INCREMENT')
        #1 - BOTTOM - LEFT
        pie.operator("snap.alignrotation", text="Align rotation", icon='SNAP_NORMAL')
        #3 - BOTTOM - RIGHT
        pie.menu("snap.targetmenu", text="Snap Target", icon='SNAP_SURFACE')    
           
#Menu Snap Target
class SnapTargetMenu(Menu):
    bl_idname = "snap.targetmenu"
    bl_label = "Snap Target Menu"

    def draw(self, context):
        layout = self.layout       
        
         
        layout.operator("object.snaptargetvariable", text="Active").variable='ACTIVE'
        layout.operator("object.snaptargetvariable", text="Median").variable='MEDIAN'
        layout.operator("object.snaptargetvariable", text="Center").variable='CENTER' 
        layout.operator("object.snaptargetvariable", text="Closest").variable='CLOSEST'

#Pie Orientation
class PieOrientation(Menu):
    bl_idname = "pie.orientation"
    bl_label = "Pie Orientation"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("object.orientationvariable", text="View").variable = 'VIEW'
        #6 - RIGHT
        pie.operator("object.orientationvariable", text="Local").variable = 'LOCAL'
        #2 - BOTTOM
        pie.operator("object.orientationvariable", text="Normal").variable = 'NORMAL'
        #8 - TOP
        pie.operator("object.orientationvariable", text="Global").variable = 'GLOBAL'
        #7 - TOP - LEFT 
        pie.operator("object.orientationvariable", text="Gimbal").variable = 'GIMBAL'
        #9 - TOP - RIGHT
        #1 - BOTTOM - LEFT
        #3 - BOTTOM - RIGHT
        
        
#Pi Shading
class PieShadingView(Menu):
    bl_idname = "pie.shadingview"
    bl_label = "Pie Shading"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("object.shadingvariable", text="Material", icon='MATERIAL').variable = 'MATERIAL'
        #6 - RIGHT
        pie.operator("object.shadingvariable", text="Wireframe", icon='WIRE').variable = 'WIREFRAME'
        #2 - BOTTOM
        pie.operator("object.shadingvariable", text="Texture", icon='TEXTURE_SHADED').variable = 'TEXTURED'
        #8 - TOP
        pie.operator("object.shadingvariable", text="Solid", icon='SOLID').variable = 'SOLID'
        #7 - TOP - LEFT 
        pie.operator("object.shadingvariable", text="Bounding box", icon='BBOX').variable = 'BOUNDBOX'
        #9 - TOP - RIGHT
        pie.operator("object.shadingvariable", text="Render", icon='SMOOTH').variable = 'RENDERED'
        #1 - BOTTOM - LEFT
        pie.operator("shading.smooth", text="Shade Smooth", icon='SOLID')
        #3 - BOTTOM - RIGHT
        pie.operator("shading.flat", text="Shade Flat", icon='MESH_ICOSPHERE')
      
#Pie Pivot Point           
class PiePivotPoint(Menu):
    bl_idname = "pie.pivotpoint"
    bl_label = "Pie Pivot Point"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("pivotpoint.variable", text="Active Element", icon='ROTACTIVE').variable = 'ACTIVE_ELEMENT'
        #6 - RIGHT
        pie.operator("pivotpoint.variable", text="Median Point", icon='ROTATECENTER').variable = 'MEDIAN_POINT'
        #2 - BOTTOM
        pie.operator("pivotpoint.variable", text="Individual Origins", icon='ROTATECOLLECTION').variable = 'INDIVIDUAL_ORIGINS'
        #8 - TOP
        pie.operator("pivotpoint.variable", text="Cursor", icon='CURSOR').variable = 'CURSOR'
        #7 - TOP - LEFT 
        pie.operator("pivotpoint.variable", text="Bounding Box Center", icon='ROTATE').variable = 'BOUNDING_BOX_CENTER'
        #9 - TOP - RIGHT
        pie.operator("use.pivotalign", text="Use Pivot Align", icon='ALIGN')
        #1 - BOTTOM - LEFT
        #3 - BOTTOM - RIGHT

#Pie ProportionalEditObj
class PieProportionalObj(Menu):
    bl_idname = "pie.proportional_obj"
    bl_label = "Pie ProportionalEditObj"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("proportional_obj.sphere", text="Sphere", icon='SPHERECURVE')
        #6 - RIGHT
        pie.operator("proportional_obj.root", text="Root", icon='ROOTCURVE')
        #2 - BOTTOM
        pie.operator("proportional_obj.smooth", text="Smooth", icon='SMOOTHCURVE')
        #8 - TOP
        pie.operator("proportional_obj.active", text="Proportional On/Off", icon='PROP_ON')
        #7 - TOP - LEFT 
        pie.operator("proportional_obj.linear", text="Linear", icon='LINCURVE')
        #9 - TOP - RIGHT
        pie.operator("proportional_obj.sharp", text="Sharp", icon='SHARPCURVE')
        #1 - BOTTOM - LEFT
        pie.operator("proportional_obj.constant", text="Constant", icon='NOCURVE')
        #3 - BOTTOM - RIGHT
        pie.operator("proportional_obj.random", text="Random", icon='RNDCURVE')

#Pie ProportionalEditEdt
class PieProportionalEdt(Menu):
    bl_idname = "pie.proportional_edt"
    bl_label = "Pie ProportionalEditEdt"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("proportional_edt.connected", text="Connected", icon='PROP_CON')
        #6 - RIGHT
        pie.operator("proportional_edt.projected", text="Projected", icon='PROP_ON')
        #2 - BOTTOM
        pie.operator("proportional_edt.smooth", text="Smooth", icon='SMOOTHCURVE')
        #8 - TOP
        pie.operator("proportional_edt.active", text="Proportional On/Off", icon='PROP_ON')
        #7 - TOP - LEFT 
        pie.operator("proportional_edt.sphere", text="Sphere", icon='SPHERECURVE')
        #9 - TOP - RIGHT
        pie.operator("proportional_edt.root", text="Root", icon='ROOTCURVE')
        #1 - BOTTOM - LEFT
        pie.operator("proportional_edt.constant", text="Constant", icon='NOCURVE')
        #3 - BOTTOM - RIGHT
        box = pie.split().column()
        row = box.row(align=True)
        box.operator("proportional_edt.linear", text="Linear", icon='LINCURVE')
        box.operator("proportional_edt.sharp", text="Sharp", icon='SHARPCURVE')
        box.operator("proportional_edt.random", text="Random", icon='RNDCURVE')
             
        
#Pie Retopo               
class PieRetopo(Menu):
    bl_idname = "pie.retopo"
    bl_label = "Pie Retopo"

    def draw(self, context):
        layout = self.layout
        
        pie = layout.menu_pie()
        #4 - LEFT
        pie.operator("mesh.looptools_gstretch", text="GStretch", icon='GREASEPENCIL')
        #6 - RIGHT
        pie.operator("object.align2x", icon='MOD_WIREFRAME')
        #2 - BOTTOM
        pie.operator("mesh.laprelax", icon = 'MOD_LATTICE')
        #8 - TOP
        pie.operator("gpencil.surfsk_add_surface", text="Add Bsurface", icon = 'MOD_DYNAMICPAINT')
        #7 - TOP - LEFT 
        pie.operator("retopo.space", icon='ALIGN', text="Space")
        #9 - TOP - RIGHT
        pie.operator("shrink.update", icon = 'MOD_SHRINKWRAP')
        #1 - BOTTOM - LEFT
        box = pie.split().column()
        row = box.row(align=True)
        box.operator("setup.retopomesh", icon = 'UV_FACESEL')
        box.operator("object.automirror", icon = 'MOD_MIRROR')
        #3 - BOTTOM - RIGHT
        pie.operator("polysculpt.retopo", text = "Sculpt Mesh", icon = 'SCULPTMODE_HLT')
              
addon_keymaps = []

def register():
    # Pie Menu Select Mode
    bpy.utils.register_class(PieObjectEditMode)
    bpy.utils.register_class(ClassObject)
    bpy.utils.register_class(ClassVertex)
    bpy.utils.register_class(ClassEdge)
    bpy.utils.register_class(ClassFace)
    bpy.utils.register_class(ClassTexturePaint)
    bpy.utils.register_class(ClassVertexPaint)
    bpy.utils.register_class(ClassWeightPaint)
    bpy.utils.register_class(ClassOccludeGeometry)
    # View Menu
    bpy.utils.register_class(PieAreaViews)
    bpy.utils.register_class(JoinArea)
    bpy.utils.register_class(SplitHorizontal)
    bpy.utils.register_class(SplitVertical)
    bpy.utils.register_class(ViewMenu)
    bpy.utils.register_class(OherViewsMenu)
    # View numpad
    bpy.utils.register_class(PieViewNumpad)
    bpy.utils.register_class(PerspOrthoView)
    # Sculpt Pie Menu
    bpy.utils.register_class(PieSculptPie)
    bpy.utils.register_class(PieSculpttwo)
    bpy.utils.register_class(SculptPolish)
    bpy.utils.register_class(SculptSculptDraw)
    # Components Selection Mode
    bpy.utils.register_class(VertsEdges)
    bpy.utils.register_class(EdgesFaces)
    bpy.utils.register_class(VertsFaces)
    bpy.utils.register_class(VertsEdgesFaces)
    # Origin/Pivot
    bpy.utils.register_class(PivotToSelection)
    bpy.utils.register_class(PieOriginPivot)
    bpy.utils.register_class(OriginPivotMenu)
    bpy.utils.register_class(PivotBottom)
    # Manipulators
    bpy.utils.register_class(PieManipulator)
    bpy.utils.register_class(WManupulators)
    bpy.utils.register_class(ManipTranslate)
    bpy.utils.register_class(ManipRotate)
    bpy.utils.register_class(ManipScale)
    bpy.utils.register_class(TranslateRotate)
    bpy.utils.register_class(TranslateScale)
    bpy.utils.register_class(RotateScale) 
    bpy.utils.register_class(TranslateRotateScale)
    # Snapping
    bpy.utils.register_class(PieSnaping)
    bpy.utils.register_class(SnapActive)
    bpy.utils.register_class(SnapVolume)
    bpy.utils.register_class(SnapFace)
    bpy.utils.register_class(SnapEdge)
    bpy.utils.register_class(SnapVertex)
    bpy.utils.register_class(SnapIncrement)
    bpy.utils.register_class(SnapAlignRotation)
    bpy.utils.register_class(SnapTargetMenu)
    bpy.utils.register_class(SnapTargetVariable)
    # Orientation
    bpy.utils.register_class(PieOrientation)
    bpy.utils.register_class(OrientationVariable)
    # Retopo
    bpy.utils.register_class(PieRetopo)
    bpy.utils.register_class(AlignToX)
    bpy.utils.register_class(RetopoSpace)
    bpy.utils.register_class(LapRelax)
    # Shading
    bpy.utils.register_class(ShadingVariable)
    bpy.utils.register_class(PieShadingView)
    bpy.utils.register_class(ShadingSmooth)
    bpy.utils.register_class(ShadingFlat)
    # Pivot Point
    bpy.utils.register_class(PivotPointVariable)
    bpy.utils.register_class(PiePivotPoint)
    bpy.utils.register_class(UsePivotAlign)
    # ProportionalEditObj
    bpy.utils.register_class(PieProportionalObj)
    bpy.utils.register_class(ProportionalEditObj)
    bpy.utils.register_class(ProportionalSmoothObj)
    bpy.utils.register_class(ProportionalSphereObj)
    bpy.utils.register_class(ProportionalRootObj)
    bpy.utils.register_class(ProportionalSharpObj)
    bpy.utils.register_class(ProportionalLinearObj)
    bpy.utils.register_class(ProportionalConstantObj)
    bpy.utils.register_class(ProportionalRandomObj)
    # ProportionalEditEdt
    bpy.utils.register_class(PieProportionalEdt)
    bpy.utils.register_class(ProportionalEditEdt)
    bpy.utils.register_class(ProportionalConnectedEdt)
    bpy.utils.register_class(ProportionalProjectedEdt)
    bpy.utils.register_class(ProportionalSmoothEdt)
    bpy.utils.register_class(ProportionalSphereEdt)
    bpy.utils.register_class(ProportionalRootEdt)
    bpy.utils.register_class(ProportionalSharpEdt)
    bpy.utils.register_class(ProportionalLinearEdt)
    bpy.utils.register_class(ProportionalConstantEdt)
    bpy.utils.register_class(ProportionalRandomEdt)
    # Preferences
    bpy.utils.register_class(WazouPieMenuPrefs)
    
    
    
    
# Keympa Config   
    
    wm = bpy.context.window_manager
    
    if wm.keyconfigs.addon:
        #Select Mode
        km = wm.keyconfigs.addon.keymaps.new(name='Object Non-modal')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'TAB', 'PRESS').properties.name = "pie.objecteditmode"
        
        #Views numpad
        km = wm.keyconfigs.addon.keymaps.new(name = '3D View Generic', space_type = 'VIEW_3D')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'Q', 'PRESS').properties.name = "pie.viewnumpad"
       
        #Views
        km = wm.keyconfigs.addon.keymaps.new(name='Screen')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'SPACE', 'PRESS').properties.name = "pie.areaviews"
        
        #Sculpt Pie Menu
        km = wm.keyconfigs.addon.keymaps.new(name='Sculpt')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'W', 'PRESS').properties.name = "pie.sculpt"
        
        #Sculpt Pie Menu 2
        km = wm.keyconfigs.addon.keymaps.new(name='Sculpt')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'W', 'PRESS', alt=True).properties.name = "pie.sculpttwo"
        
        #Origin/Pivot
        km = wm.keyconfigs.addon.keymaps.new(name = '3D View Generic', space_type = 'VIEW_3D')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'S', 'PRESS', shift=True).properties.name = "pie.originpivot"
        
        #Manipulators
        km = wm.keyconfigs.addon.keymaps.new(name = '3D View Generic', space_type = 'VIEW_3D')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'SPACE', 'PRESS', ctrl=True).properties.name = "pie.manipulator"
        
        #Snapping
        km = wm.keyconfigs.addon.keymaps.new(name = '3D View Generic', space_type = 'VIEW_3D')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'TAB', 'PRESS', shift=True).properties.name = "pie.snapping"
        
        #Orientation
        km = wm.keyconfigs.addon.keymaps.new(name = '3D View Generic', space_type = 'VIEW_3D')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'SPACE', 'PRESS', alt=True).properties.name = "pie.orientation"
        
        #Retopo
        km = wm.keyconfigs.addon.keymaps.new(name = '3D View Generic', space_type = 'VIEW_3D')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'RIGHTMOUSE', 'PRESS', shift=True).properties.name = "pie.retopo"
        
        #Shading
        km = wm.keyconfigs.addon.keymaps.new(name = '3D View Generic', space_type = 'VIEW_3D')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'Z', 'PRESS').properties.name = "pie.shadingview"
        
        #Pivot Point
        km = wm.keyconfigs.addon.keymaps.new(name = '3D View Generic', space_type = 'VIEW_3D')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'Q', 'PRESS', alt=True).properties.name = "pie.pivotpoint"
        
        #ProportionalEditObj
        km = wm.keyconfigs.addon.keymaps.new(name = 'Object Mode')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'O', 'PRESS').properties.name = "pie.proportional_obj"

        #ProportionalEditEdt
        km = wm.keyconfigs.addon.keymaps.new(name = 'Mesh')
        kmi = km.keymap_items.new('wm.call_menu_pie', 'O', 'PRESS').properties.name = "pie.proportional_edt"
        
        addon_keymaps.append(km)

# Register / Unregister Classes
def unregister():
    # Pie Menu Select Mode
    bpy.utils.unregister_class(PieObjectEditMode)
    bpy.utils.unregister_class(ClassObject)
    bpy.utils.unregister_class(ClassVertex)
    bpy.utils.unregister_class(ClassEdge)
    bpy.utils.unregister_class(ClassFace)
    bpy.utils.unregister_class(ClassTexturePaint)
    bpy.utils.unregister_class(ClassVertexPaint)
    bpy.utils.unregister_class(ClassWeightPaint)
    bpy.utils.unregister_class(ClassOccludeGeometry)
    # View Menu
    bpy.utils.unregister_class(PieAreaViews)
    bpy.utils.unregister_class(JoinArea)
    bpy.utils.unregister_class(SplitHorizontal)
    bpy.utils.unregister_class(SplitVertical)
    bpy.utils.unregister_class(ViewMenu)
    bpy.utils.unregister_class(OherViewsMenu)
    # View numpad
    bpy.utils.unregister_class(PieViewNumpad)
    bpy.utils.unregister_class(PerspOrthoView)
    # Sculpt Pie Menu
    bpy.utils.unregister_class(PieSculptPie)
    bpy.utils.unregister_class(PieSculpttwo)
    bpy.utils.unregister_class(SculptPolish)
    bpy.utils.unregister_class(SculptSculptDraw)
    # Components Selection Mode
    bpy.utils.unregister_class(VertsEdges)
    bpy.utils.unregister_class(EdgesFaces)
    bpy.utils.unregister_class(VertsFaces)
    bpy.utils.unregister_class(VertsEdgesFaces)
    # Origin/Pivot
    bpy.utils.unregister_class(PivotToSelection)
    bpy.utils.unregister_class(PieOriginPivot)
    bpy.utils.unregister_class(OriginPivotMenu)
    bpy.utils.unregister_class(PivotBottom)
    # Manipulators
    bpy.utils.unregister_class(PieManipulator)
    bpy.utils.unregister_class(WManupulators)
    bpy.utils.unregister_class(ManipTranslate)
    bpy.utils.unregister_class(ManipRotate)
    bpy.utils.unregister_class(ManipScale)
    bpy.utils.unregister_class(TranslateRotate)
    bpy.utils.unregister_class(TranslateScale)
    bpy.utils.unregister_class(RotateScale) 
    bpy.utils.unregister_class(TranslateRotateScale)
    # Snapping
    bpy.utils.unregister_class(PieSnaping)
    bpy.utils.unregister_class(SnapActive)
    bpy.utils.unregister_class(SnapVolume)
    bpy.utils.unregister_class(SnapFace)
    bpy.utils.unregister_class(SnapEdge)
    bpy.utils.unregister_class(SnapVertex)
    bpy.utils.unregister_class(SnapIncrement)
    bpy.utils.unregister_class(SnapAlignRotation)
    bpy.utils.unregister_class(SnapTargetMenu)
    bpy.utils.unregister_class(SnapTargetVariable)
    # Orientation
    bpy.utils.unregister_class(PieOrientation)
    bpy.utils.unregister_class(OrientationVariable)
    #Retopo
    bpy.utils.unregister_class(PieRetopo)
    bpy.utils.unregister_class(AlignToX)
    bpy.utils.unregister_class(RetopoSpace)
    bpy.utils.unregister_class(LapRelax)
    # Shading
    bpy.utils.unregister_class(ShadingVariable)
    bpy.utils.unregister_class(PieShadingView) 
    bpy.utils.unregister_class(ShadingSmooth)
    bpy.utils.unregister_class(ShadingFlat)
    # Pivot Point
    bpy.utils.unregister_class(PivotPointVariable)
    bpy.utils.unregister_class(PiePivotPoint) 
    bpy.utils.unregister_class(UsePivotAlign)
    # ProportionalEditObj
    bpy.utils.unregister_class(PieProportionalObj)
    bpy.utils.unregister_class(ProportionalEditObj)
    bpy.utils.unregister_class(ProportionalSmoothObj)
    bpy.utils.unregister_class(ProportionalSphereObj)
    bpy.utils.unregister_class(ProportionalRootObj)
    bpy.utils.unregister_class(ProportionalSharpObj)
    bpy.utils.unregister_class(ProportionalLinearObj)
    bpy.utils.unregister_class(ProportionalConstantObj)
    bpy.utils.unregister_class(ProportionalRandomObj)
    # ProportionalEditEdt
    bpy.utils.unregister_class(PieProportionalEdt)
    bpy.utils.unregister_class(ProportionalEditEdt)
    bpy.utils.unregister_class(ProportionalConnectedEdt)
    bpy.utils.unregister_class(ProportionalProjectedEdt)
    bpy.utils.unregister_class(ProportionalSmoothEdt)
    bpy.utils.unregister_class(ProportionalSphereEdt)
    bpy.utils.unregister_class(ProportionalRootEdt)
    bpy.utils.unregister_class(ProportionalSharpEdt)
    bpy.utils.unregister_class(ProportionalLinearEdt)
    bpy.utils.unregister_class(ProportionalConstantEdt)
    bpy.utils.unregister_class(ProportionalRandomEdt)
    # Preferences
    bpy.utils.unregister_class(WazouPieMenuPrefs)
    
    wm = bpy.context.window_manager

    if wm.keyconfigs.addon:
        for km in addon_keymaps:
            for kmi in km.keymap_items:
                km.keymap_items.remove(kmi)

            wm.keyconfigs.addon.keymaps.remove(km)

    # clear the list
    del addon_keymaps[:]

if __name__ == "__main__":
    register()



